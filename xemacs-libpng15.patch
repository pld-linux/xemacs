--- xemacs-21.5.29/src/glyphs-eimage.c~	2009-05-18 16:51:08.000000000 +0200
+++ xemacs-21.5.29/src/glyphs-eimage.c	2012-02-11 09:39:23.780721443 +0100
@@ -948,8 +948,8 @@
   {
     int y;
     Binbyte **row_pointers;
-    height = info_ptr->height;
-    width = info_ptr->width;
+    height = png_get_image_height(png_ptr, info_ptr);
+    width = png_get_image_width(png_ptr, info_ptr);
 
     /* Wow, allocate all the memory.  Truly, exciting. */
     unwind.eimage = xnew_array_and_zero (Binbyte, width * height * 3);
@@ -1001,22 +1001,22 @@
     /* Now that we're using EImage, ask for 8bit RGB triples for any type
        of image*/
     /* convert palette images to full RGB */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE)
       png_set_expand (png_ptr);
     /* send grayscale images to RGB too */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY ||
+        png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA)
       png_set_gray_to_rgb (png_ptr);
     /* we can't handle alpha values */
-    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
+    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA)
       png_set_strip_alpha (png_ptr);
     /* tell libpng to strip 16 bit depth files down to 8 bits */
-    if (info_ptr->bit_depth == 16)
+    if (png_get_bit_depth(png_ptr, info_ptr) == 16)
       png_set_strip_16 (png_ptr);
     /* if the image is < 8 bits, pad it out */
-    if (info_ptr->bit_depth < 8)
+    if (png_get_bit_depth(png_ptr, info_ptr) < 8)
       {
-	if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)
+	if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY)
 	  png_set_expand (png_ptr);
 	else
 	  png_set_packing (png_ptr);
@@ -1036,19 +1036,21 @@
     /* #### I've turned this on, since these warnings are now
        unobtrusive. */
     {
-      int i;
+      int i, num_text;
+      png_textp text_ptr;
       DECLARE_EISTRING (key);
       DECLARE_EISTRING (text);
+      png_get_text(png_ptr, info_ptr, &text_ptr, &num_text);
 
-      for (i = 0 ; i < info_ptr->num_text ; i++)
+      for (i = 0 ; i < num_text ; i++)
 	{
 	  /* How paranoid do I have to be about no trailing NULLs, and
 	     using (int)info_ptr->text[i].text_length, and strncpy and a temp
 	     string somewhere? */
           eireset(key);
           eireset(text);
-          eicpy_ext(key, info_ptr->text[i].key, Qbinary);
-          eicpy_ext(text, info_ptr->text[i].text, Qbinary);
+          eicpy_ext(key, text_ptr[i].key, Qbinary);
+          eicpy_ext(text, text_ptr[i].text, Qbinary);
 
 	  warn_when_safe (Qpng, Qinfo, "%s - %s",
 			  eidata(key), eidata(text));
